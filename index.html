<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>廖卫红</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="廖卫红">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="廖卫红">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="廖卫红">
  
    <link rel="alternative" href="/atom.xml" title="廖卫红" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">weihong Liao</a></h1>
        </hgroup>

        
        <p class="header-subtitle">往事浓淡，色如清，已轻。经年悲喜，净如镜，已静。</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">前端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="/65925265@qq.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/lweihong" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="#" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl twitter" target="_blank" href="#" title="twitter">twitter</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/" style="font-size: 10px;">$</a> <a href="/tags/detachEvent/" style="font-size: 10px;">.detachEvent</a> <a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/BOM/" style="font-size: 10px;">BOM</a> <a href="/tags/Boolean/" style="font-size: 10px;">Boolean()</a> <a href="/tags/Date/" style="font-size: 10px;">Date</a> <a href="/tags/Function/" style="font-size: 10px;">Function</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/NaN/" style="font-size: 10px;">NaN</a> <a href="/tags/Node/" style="font-size: 10px;">Node</a> <a href="/tags/Object-create/" style="font-size: 10px;">Object.create</a> <a href="/tags/String/" style="font-size: 10px;">String()</a> <a href="/tags/proto/" style="font-size: 10px;">__proto__</a> <a href="/tags/activeObject/" style="font-size: 10px;">activeObject</a> <a href="/tags/addClass/" style="font-size: 10px;">addClass</a> <a href="/tags/addEventListener/" style="font-size: 10px;">addEventListener</a> <a href="/tags/after/" style="font-size: 10px;">after</a> <a href="/tags/alert/" style="font-size: 10px;">alert</a> <a href="/tags/animate/" style="font-size: 10px;">animate</a> <a href="/tags/append/" style="font-size: 10px;">append</a> <a href="/tags/apply/" style="font-size: 10px;">apply</a> <a href="/tags/arguments/" style="font-size: 20px;">arguments</a> <a href="/tags/arr-pop/" style="font-size: 10px;">arr.pop()</a> <a href="/tags/arr-push/" style="font-size: 10px;">arr.push()</a> <a href="/tags/arr-shift/" style="font-size: 10px;">arr.shift()</a> <a href="/tags/arr-unshift/" style="font-size: 10px;">arr.unshift()</a> <a href="/tags/attachEvent/" style="font-size: 10px;">attachEvent</a> <a href="/tags/attr/" style="font-size: 10px;">attr</a> <a href="/tags/before/" style="font-size: 10px;">before</a> <a href="/tags/break/" style="font-size: 10px;">break</a> <a href="/tags/call/" style="font-size: 20px;">call</a> <a href="/tags/charAt/" style="font-size: 10px;">charAt()</a> <a href="/tags/click/" style="font-size: 10px;">click</a> <a href="/tags/client/" style="font-size: 10px;">client</a> <a href="/tags/cloneNode/" style="font-size: 10px;">cloneNode</a> <a href="/tags/close/" style="font-size: 10px;">close</a> <a href="/tags/confirm/" style="font-size: 10px;">confirm</a> <a href="/tags/constructor/" style="font-size: 10px;">constructor</a> <a href="/tags/continue/" style="font-size: 10px;">continue</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/do-while/" style="font-size: 10px;">do while</a> <a href="/tags/document-getElementById/" style="font-size: 10px;">document.getElementById()</a> <a href="/tags/document-getElementsByTagName/" style="font-size: 10px;">document.getElementsByTagName()</a> <a href="/tags/else/" style="font-size: 10px;">else</a> <a href="/tags/empty/" style="font-size: 10px;">empty</a> <a href="/tags/extend/" style="font-size: 10px;">extend()</a> <a href="/tags/fadeIn/" style="font-size: 10px;">fadeIn</a> <a href="/tags/fadeTo/" style="font-size: 10px;">fadeTo</a> <a href="/tags/fadeToggle/" style="font-size: 10px;">fadeToggle</a> <a href="/tags/for/" style="font-size: 10px;">for</a> <a href="/tags/hide/" style="font-size: 10px;">hide</a> <a href="/tags/html/" style="font-size: 20px;">html</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/indexOf/" style="font-size: 10px;">indexOf()</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/isNaN/" style="font-size: 10px;">isNaN</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/lastIndexOf/" style="font-size: 10px;">lastIndexOf()</a> <a href="/tags/mouseenter/" style="font-size: 10px;">mouseenter</a> <a href="/tags/mouseleave/" style="font-size: 10px;">mouseleave</a> <a href="/tags/offset/" style="font-size: 10px;">offset</a> <a href="/tags/offsetHeight/" style="font-size: 20px;">offsetHeight</a> <a href="/tags/offsetLeft/" style="font-size: 10px;">offsetLeft</a> <a href="/tags/offsetTop/" style="font-size: 10px;">offsetTop</a> <a href="/tags/offsetWidt/" style="font-size: 10px;">offsetWidt</a> <a href="/tags/offsetWidth/" style="font-size: 10px;">offsetWidth</a> <a href="/tags/on/" style="font-size: 10px;">on</a> <a href="/tags/onclick/" style="font-size: 10px;">onclick</a> <a href="/tags/onmouseout/" style="font-size: 10px;">onmouseout</a> <a href="/tags/onmouseover/" style="font-size: 10px;">onmouseover</a> <a href="/tags/open/" style="font-size: 10px;">open</a> <a href="/tags/position/" style="font-size: 10px;">position</a> <a href="/tags/prepend/" style="font-size: 10px;">prepend</a> <a href="/tags/prop/" style="font-size: 10px;">prop</a> <a href="/tags/prototype/" style="font-size: 20px;">prototype</a> <a href="/tags/remove/" style="font-size: 10px;">remove</a> <a href="/tags/removeClass/" style="font-size: 10px;">removeClass</a> <a href="/tags/removeEventListener/" style="font-size: 10px;">removeEventListener</a> <a href="/tags/replace/" style="font-size: 10px;">replace()</a> <a href="/tags/scroll/" style="font-size: 20px;">scroll</a> <a href="/tags/scrollLeft/" style="font-size: 10px;">scrollLeft</a> <a href="/tags/scrollTop/" style="font-size: 10px;">scrollTop</a> <a href="/tags/show/" style="font-size: 10px;">show</a> <a href="/tags/slideDown/" style="font-size: 10px;">slideDown</a> <a href="/tags/slideToggle/" style="font-size: 10px;">slideToggle</a> <a href="/tags/slideUp/" style="font-size: 10px;">slideUp</a> <a href="/tags/str-concat/" style="font-size: 10px;">str.concat()</a> <a href="/tags/str-slice/" style="font-size: 10px;">str.slice()</a> <a href="/tags/str-split/" style="font-size: 10px;">str.split("-")</a> <a href="/tags/str-substr/" style="font-size: 10px;">str.substr()</a> <a href="/tags/str-toLowerCase/" style="font-size: 10px;">str.toLowerCase()</a> <a href="/tags/str-toUpperCase/" style="font-size: 10px;">str.toUpperCase()</a> <a href="/tags/switch-case/" style="font-size: 10px;">switch case</a> <a href="/tags/text/" style="font-size: 10px;">text</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/toString/" style="font-size: 10px;">toString</a> <a href="/tags/toggleClass/" style="font-size: 10px;">toggleClass</a> <a href="/tags/undefined/" style="font-size: 10px;">undefined</a> <a href="/tags/val/" style="font-size: 10px;">val</a> <a href="/tags/value/" style="font-size: 10px;">value</a> <a href="/tags/while/" style="font-size: 10px;">while</a> <a href="/tags/动画/" style="font-size: 10px;">动画</a> <a href="/tags/选择器/" style="font-size: 10px;">选择器</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lweihong.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">weihong Liao</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">weihong Liao</a></h1>
            </hgroup>
            
            <p class="header-subtitle">往事浓淡，色如清，已轻。经年悲喜，净如镜，已静。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">前端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="/65925265@qq.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/lweihong" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="twitter" target="_blank" href="#" title="twitter">twitter</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-面向对象之五篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/面向对象之五篇/" class="article-date">
      <time datetime="2016-11-07T10:22:42.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/面向对象之五篇/">面向对象之五篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li><p>函数的四种调用模式</p>
<ol>
<li>普通函数执行<ul>
<li>this -&gt; window</li>
<li>声明一个函数后，就直接调用</li>
</ul>
</li>
<li>方法调用模式<ul>
<li>this —&gt; 该方法的调用者</li>
<li>通过一个对象来调用方法</li>
</ul>
</li>
<li>构造函数模式<ul>
<li>this -&gt; 当前创建出来的对象</li>
<li>配合new操作符 来 调用函数</li>
</ul>
</li>
<li>call/apply(上下文)模式<ul>
<li>this -&gt; 用户动态指定的<ul>
<li>指定call or apply 方法的第一个参数</li>
</ul>
</li>
<li>区别：<ul>
<li><fn>.call(thisObj, arg1, arg2, …,argN)：thisObj为 this的指向。之后为形参列表，就是fn在执行时的实参列表</fn></li>
<li><fn>.apply(thisObj, [实参]): thisObj 为 this的指向，数组参数为 fn在执行时的实参</fn></li>
</ul>
</li>
<li>注意：在非严格模式下，如果thisObj 赋值为 null 或者不传实参，此时this -&gt; window 对象，就相当于 普通函数执行模式。</li>
</ul>
</li>
<li><p>上下文模式的应用</p>
<ul>
<li>1 数组的合并<ul>
<li><code>Array.prototype.push.apply(arr1, arr2);</code></li>
</ul>
</li>
<li>2 借调方法（函数）<ul>
<li>借用构造函数  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function parent(name, age, gender) &#123;</div><div class="line">     this.name = name;</div><div class="line">     this.age = age;</div><div class="line">     this.gender = gender;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> function child(name, age, gender, address) &#123;</div><div class="line">     parent.call(this, name, age, gender);</div><div class="line">     this.address = address;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数组去重</p>
<ul>
<li>实现思路：<ul>
<li>声明一个函数实现数组去重，取名为unique；</li>
<li>判断浏览器是否支持数组的indexOf方法</li>
<li>如果不支持，就自己实现数组的indexOf方法，并且将其扩展到数组的原型对象上。</li>
<li>遍历数组，首先判断结果数组ret中是否含有当前遍历到的元素，</li>
<li>如果没有，就将当前元素添加到ret中。</li>
<li>循环结束，将ret返回。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  var arr = [1, 2, 2 , &apos;1&apos;];</div><div class="line">// indexOf</div><div class="line">function unique(a) &#123;</div><div class="line">	// 如果不支持indexOf方法</div><div class="line">	// 自己实现数组的indexOf方法，并添加到数组的原型对象上。</div><div class="line">	if( !ret.indexOf )&#123;</div><div class="line">		Array.prototype.indexOf = function(val) &#123;</div><div class="line">			// this指向的就是 indexOf的调用者 （数组对象）</div><div class="line">			// 如果循环顺利执行完，就表示没有val值，返回-1；</div><div class="line">			// 否则返回val在当前数组中的下标值。</div><div class="line">			for(var i = 0,l = this.length; i &lt; l; i++)&#123;</div><div class="line">				if(this[i] === val) return i;</div><div class="line">			&#125;</div><div class="line">			return -1;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	for(var i = 0,l = a.length;i &lt; l; i++)&#123;</div><div class="line">		// 如果ret中不存在当前遍历到的元素，就添加到ret中</div><div class="line">		// 否则就不要添加</div><div class="line">		if( ret.indexOf(a[i]) === -1 )&#123;</div><div class="line">			ret.push(a[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return ret;</div><div class="line">&#125;</div><div class="line">console.log(unique(arr));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript进阶篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apply/">apply</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/call/">call</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面向对象之四篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/面向对象之四篇/" class="article-date">
      <time datetime="2016-11-07T09:51:33.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/面向对象之四篇/">面向对象之四篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>instanceof运算规则：<br>如果运算符后面的函数 的prototype属性所引用的对象，<br>出现在 运算符前面的对象 的原型链上的话，就返回true；<br>否则就返回false。</li>
<li><p>绘制作用域链的规则<br>1》 将整个script标签的全局作用域，定义为0级作用域链。将全局作用域上的数据（变量、函数、对象等等）绘制在该链上。<br>2》由于在词法作用域中，只有函数可以分割作用域。因此，只要遇到函数，就要引申出新的作用域链，级别为当前链的级别 + 1；<br>3》 重复第二步骤，直到没有遇到函数为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  var n = 123; </div><div class="line">function f(argument) &#123;</div><div class="line">	var n;</div><div class="line">	function f1(argument) &#123;</div><div class="line">		var n;</div><div class="line">		function f2(argument) &#123;</div><div class="line">			// var n ;</div><div class="line">			// n = 0;</div><div class="line">			console.log(n);</div><div class="line">		&#125;</div><div class="line">		function f3() &#123;&#125;</div><div class="line">		f2();</div><div class="line">		n = 1;</div><div class="line">	&#125;</div><div class="line">	f1();</div><div class="line">	n = 12;</div><div class="line">&#125;</div><div class="line">f();</div></pre></td></tr></table></figure>
<p>绘制作用域链图：<br><img src="./images/绘制作用域链.jpg" alt="绘制作用域链"></p>
</li>
<li>变量的搜索原则：当访问一个变量时，<br>1》 首先在当前变量所处作用域链上查找，如果找到就直接使用，并停止查找；<br>2》 如果没有找到，就向上一级链（T - 1）上去查找，如果找到就直接使用，并停止查找；<br>3》 如果没有找到，就继续向上一级链查找。直到0级链，如果找到就直接使用，并停止查找；<br>4》 如果没有找到就报错。<br>注意：<br>1》 如果访问的变量不存在，会搜索整个作用域链（不仅性能低，而且抛出异常。）<pre><code>在开发时，不推崇所有数据都写在全局上。尽量使用局部变量。推荐使用沙箱。
如果在开发中，所有js代码都写在全局上，会造成全局变量的污染。
</code></pre>2》同级别的链上的变量互不干扰。</li>
<li>在函数执行的时候，会创建一个执行的环境，包括activeObject（活动对象）以及作用域链<br>1&gt; activeObject: 存储的是所有在函数内部定义的变量，以及函数的形参；<pre><code>会将变量名字以及形参名字作为该对象的属性来存储
</code></pre></li>
<li>闭包<br>1》 概念：一个函数有权去访问另一个函数的内部数据。<br>2》缺点： 会造成函数内部的数据常驻内存，从而引发内存泄漏的问题。<br>3》解决的问题：解决在函数外部无法访问函数内部的数据。s<br>4》为了防止闭包导致内存泄漏，在使用完闭包后，将其赋值为null即可。<br>5》闭包怎么缓存数据？因为在函数内部有方法（函数）对其有引用，并且又将其返回到外部作用域上的一个变量接收。<br>多闭包的结构:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  function foo() &#123;</div><div class="line">	var n = 1,</div><div class="line">		m = &#123;age : 19&#125;;</div><div class="line">	function getN() &#123;</div><div class="line">		return n;</div><div class="line">	&#125;</div><div class="line">	function getM() &#123;</div><div class="line">		return m;</div><div class="line">	&#125;</div><div class="line">	var obj = &#123;&#125;;</div><div class="line">	obj.getM = getM;</div><div class="line">	obj.getN = getN;</div><div class="line">	return obj;</div><div class="line">	// return &#123;</div><div class="line">	// 		getM: getM,</div><div class="line">	// 		getN: getN</div><div class="line">	// &#125;</div><div class="line">&#125;</div><div class="line">var obj = foo();</div><div class="line">obj.getM().age = 20;</div><div class="line">console.log(obj.getM().age);	//20</div><div class="line">console.log(obj.getN());		//1</div><div class="line">var obj1 = foo();</div><div class="line">console.log(obj1.getM().age);	//19</div><div class="line">console.log(obj1.getN());		//1</div><div class="line">obj = null;</div><div class="line">obj1 = null;</div></pre></td></tr></table></figure>
</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  function foo() &#123;</div><div class="line">	function fn() &#123;</div><div class="line">		var n = Math.random();</div><div class="line">		function getN() &#123;</div><div class="line">			return n;</div><div class="line">		&#125;</div><div class="line">		return getN;</div><div class="line">	&#125;</div><div class="line">	var ff = fn();</div><div class="line">	var nn = ff();</div><div class="line">	var mm = ff();</div><div class="line">	var dd = ff();</div><div class="line">	// var nn = fn();</div><div class="line">	// var mm = fn();</div><div class="line">	console.log(nn);</div><div class="line">	console.log(mm);</div><div class="line">	console.log(dd);</div><div class="line">	console.log(nn === mm);		//true</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>

闭包作用域图：
![闭包作用域图](./images/闭包的作用域链.jpg)
</code></pre><ol>
<li><p>垃圾回收机制：GC（Garbage Collection）</p>
<ol>
<li>　引用计数<br> 如果一个变量被另一个变量引用，那么该变量的应用计数+1；当这个变量不再引用该变量（该变量被回收掉了）时，<br> 此时这个变量的引用计数 - 1；<br> GC会在一定时间间隔去查看每个变量的计数，如果为0， 就将其占用的内存回收。<br>缺点： 循环引用：会造成无法回收变量的内存<br> a{ val : b} , b{val:ａ} b = null;(a = null)<br>２.　标记清除<br> 从当前文档根部（window对象）找一条路径，如果能到达该变量，那么说明此变量不应该 被回收掉<br> 反之，应该被回收其所占用的内存。<br> –如果变量进入某个执行环境，那么给其标记为 “进入环境”；<br> –如果上述执行环境执行完成，被销毁，那么该环境内的所有变量都被标记为“已出环境”<br> –如果变量被标记为已出环境，就会被回收掉其占用的内存空间。</li>
</ol>
</li>
<li><p>闭包的应用</p>
<ol>
<li><p>计数器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  // 统计某个构造函数创建多少个对象？</div><div class="line">function Counter() &#123;</div><div class="line">	var n = 0; // 进入环境</div><div class="line">	return &#123;</div><div class="line">		add: function() &#123;</div><div class="line">			n++;</div><div class="line">		&#125;,</div><div class="line">		getCounts: function() &#123;</div><div class="line">			return n;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var PersonCount = Counter();</div><div class="line">var animalCouter = Counter(); // 0</div><div class="line">function Person() &#123;</div><div class="line">	PersonCount.add();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p0 = new Person();</div><div class="line">var p1 = new Person();</div><div class="line">var p2 = new Person();</div><div class="line">var p3 = new Person();</div><div class="line">var p4 = new Person();</div><div class="line">var p5 = new Person();</div><div class="line">console.log(PersonCount.getCounts()); // 6</div><div class="line">console.log(animalCouter.getCounts()); // 0</div></pre></td></tr></table></figure>
</li>
<li><p>对象的私有属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  		function person(name, age) &#123;		</div><div class="line">	// 工厂模式</div><div class="line">	// var obj = &#123;&#125;;</div><div class="line">	// obj.name = name;</div><div class="line">	// obj.age = age;</div><div class="line">	// return obj;</div><div class="line">	// 闭包模拟私有属性</div><div class="line">	return &#123;</div><div class="line">		getName: function() &#123;</div><div class="line">			return name;</div><div class="line">		&#125;,</div><div class="line">		getAge: function() &#123;</div><div class="line">			return age;</div><div class="line">		&#125;,</div><div class="line">		setAge: function(val) &#123;</div><div class="line">			age = val;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var xiaohong = person(&apos;小红&apos;, 18);</div><div class="line">console.log(xiaohong.getName());	//小红</div><div class="line">console.log(xiaohong.getAge());		//18</div><div class="line">Object.preventExtensions(xiaohong);</div><div class="line">xiaohong.name = &apos;小绿&apos;;</div><div class="line">console.log(xiaohong.getName());	//小红</div><div class="line">console.log(xiaohong.name);		//undefined</div><div class="line">// es5</div><div class="line">Object.preventExtensions(xiaohong);</div><div class="line">xiaohong.setAge(19);</div><div class="line">console.log(xiaohong.getAge());		// 19</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<pre><code>3. 解决fib数列递归性能
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">  // 利用闭包可以缓存数据的特性，改善递归性能。</div><div class="line">// fib(5)</div><div class="line">var fib = (function() &#123;</div><div class="line">	var cache = [];</div><div class="line">	return function(n) &#123;</div><div class="line">		if (n &lt; 1) return undefined;</div><div class="line">		// 1: 第一步看缓存里有没有</div><div class="line">		// 如果有，直接返回缓存内的值</div><div class="line">		if (!!cache[n]) return cache[n];</div><div class="line">		// 2：如果没有，重新计算</div><div class="line">		else &#123;</div><div class="line">			// 如果n=1|n=2，值为1</div><div class="line">			if (n === 1 || n === 2) &#123;</div><div class="line">				// 将计算后的结果缓存起来</div><div class="line">				cache[n] = 1;</div><div class="line">			&#125; else &#123; // 如果n的值大于2，递归去求值</div><div class="line">				// 将计算后的结果缓存起来</div><div class="line">				cache[n] = arguments.callee(n - 1) + arguments.callee(n - 2);</div><div class="line">			&#125;</div><div class="line">			return cache[n];</div><div class="line">			// 高级写法</div><div class="line">			// return cache[n] = n === 1 || n === 2 ? </div><div class="line">			// 		1　:　</div><div class="line">			// 		arguments.callee(n - 1) + arguments.callee(n - 2);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">console.log(fib(5)); // 1 1 2 3 5</div></pre></td></tr></table></figure>

4. 沙箱模式： 好处： 不会污染全局变量（或者其他作用域的变量），并且能保证自己的代码安全执行。
特性：a:  能分割作用域，不会污染全局 fn
          b:  在分割后的作用域内部的代码要能自执行。fn()
结构：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function ()&#123;</div><div class="line">     //代码块</div><div class="line">     window.fn = fn;		</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript进阶篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/activeObject/">activeObject</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/instanceof/">instanceof</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面向对象之三篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/面向对象之三篇/" class="article-date">
      <time datetime="2016-11-07T08:14:13.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/面向对象之三篇/">面向对象之三篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>Function的介绍<br>1》创建函数的方式<br>a: 声明式<br>b: 表达式<br>c: 构造函数： Function（arg1, arg2, …,argN ，body）所有的参数类型均为 字符串；<br>arg1, arg2, …,argN 为可选的参数列表，表示 为 生成函数的形参列表；<br>body 为必选参数，表示为 生成函数的 函数体部分。</p>
<p>2》由于函数也可以通过Function构造函数来创建，那么函数也是对象；具有<code>__proto__</code>属性</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">   // 创建函数的方式</div><div class="line">// 1：声明式</div><div class="line">function foo() &#123;</div><div class="line">	console.log(arguments);</div><div class="line">&#125;</div><div class="line">foo(1, 2, &quot;3&quot;, &#123;name:&apos;jerry&apos;&#125;);</div><div class="line">// 2: 表达式</div><div class="line">var foo = function() &#123;</div><div class="line">	console.log(arguments);</div><div class="line">&#125;;</div><div class="line">foo(1, 2, &quot;3&quot;, &#123;name:&apos;jerry&apos;&#125;, true);</div><div class="line">// 3: 构造函数</div><div class="line">Function(arg1, arg2, ...,argN, body);</div><div class="line">// arg1, arg2, ...,argN 为可选的形参列表，表达为 创建出来的函数的 形参列表，数据类型字符串</div><div class="line">// body 字符串类型，表达为：创建出来的函数的 函数体部分</div><div class="line">var foo = new Function(&apos;val1&apos;, &apos;val2&apos;, &apos;return val1 + val2;&apos;);</div><div class="line">var foo = new Function(&apos;return arguments[0] + arguments[1];&apos;);</div><div class="line">console.log(foo(1)); // 3</div><div class="line">console.log(foo);</div><div class="line">// 函数也是对象</div><div class="line">// __proto__</div><div class="line">console.log(!!foo.__proto__); // true</div></pre></td></tr></table></figure>
</li>
<li><p>相关结论：<br>1》 所有的函数都是Function实例。<br>2》所有的函数的构造函数为Function;<br>3》所有的函数的原型对象 为 Function.prototype.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">  // Object函数的构造函数为 Function</div><div class="line">console.log(Object.constructor);  //Function() &#123; [native code] &#125;</div><div class="line">// Array Function</div><div class="line">console.log(Array.constructor);  //Function() &#123; [native code] &#125;</div><div class="line">console.log(Date.constructor);  //Function() &#123; [native code] &#125;</div><div class="line">console.log(RegExp.constructor);  //Function() &#123; [native code] &#125;</div><div class="line">var foo = function() &#123;&#125;;</div><div class="line">console.log(foo.constructor);  //Function() &#123; [native code] &#125;</div><div class="line">// 结论：</div><div class="line">// 所有的函数都是Function实例。</div><div class="line">// 那么也就是说 所有的函数的构造函数为Function;</div><div class="line">// 所有的函数的原型对象 为 Function.prototype.</div><div class="line">console.log(foo.__proto__ === Function.prototype);  //true</div><div class="line">console.log(Object.__proto__ === Function.prototype);  //true</div><div class="line">console.log(Array.__proto__ === Function.prototype);  //true</div><div class="line">console.log(Date.__proto__ === Function.prototype);  //true</div><div class="line">console.log(RegExp.__proto__ === Function.prototype);  //true</div><div class="line">// Function.prototype的原型对象是谁？</div><div class="line">console.log( Function.prototype.__proto__ === Object.prototype );</div><div class="line">console.log( typeof Function.prototype );  //function</div><div class="line">console.log(Function.prototype.prototype);  //undefined</div><div class="line">// Array -&gt; Function.prototype -&gt; Object.prototype -&gt; null</div><div class="line">// 将函数   称为 函数对象</div><div class="line">// 其他对象 称为 普通对象</div></pre></td></tr></table></figure>
</li>
<li><p>将函数称为函数对象<br>其他对象称为普通对象</p>
</li>
<li>绘制函数的原型链</li>
<li><p>arguments对象属性<br>1&gt;: length 实参的个数<br>2&gt;：callee 返回正在执行的函数; 应用在匿名函数递归调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   // 如果函数没有传递实参，就直接打印false；</div><div class="line">// 如果传递一个实参，就将其直接打印出来；</div><div class="line">// 如果传递两个实参，就将两个实参拼接起来，在打印出来；</div><div class="line">// 如果传递一个实参并且类型为 数字的话，就加1，在打印。</div><div class="line">	function foo() &#123;</div><div class="line">		if(arguments.length === 0)&#123;</div><div class="line">			console.log(false);</div><div class="line">		&#125; else if(arguments.length === 1)&#123;</div><div class="line">			if(typeof arguments[0] === &apos;number&apos;)&#123;</div><div class="line">				console.log(arguments[0] + 1);</div><div class="line">			&#125; else &#123;</div><div class="line">				console.log(arguments[0]);</div><div class="line">			&#125;</div><div class="line">		&#125; else if(arguments.length === 2)&#123;</div><div class="line">			console.log(arguments[0] + &apos;&apos; + arguments[1]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	foo();		//false</div><div class="line">	foo(1);		//2</div><div class="line">	foo(&quot;JQK&quot;);		//JQK</div><div class="line">	foo(&apos;A&apos;, &apos;2&apos;);		//A2</div></pre></td></tr></table></figure>
</li>
<li><p>函数相关属性<br>1&gt;：caller 返回调用当前函数的函数<br>2&gt;: length 形参的个数<br>3&gt;: name   存储函数的名字</p>
</li>
<li>模拟函数重载<br> 在js中，没有函数重载，只能通过arguments对象进行模拟</li>
<li><p>函数递归：<br>1&gt;  概念：函数调用自身<br> 递归调用的时候，都要加上递归调用的开始条件<br>2&gt; 经典递归案例<br>a:  等差数列第n项值</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">	// 概念：函数调用自身</div><div class="line">// 递归调用的时候，都要加上递归调用的开始条件</div><div class="line">function foo() &#123;</div><div class="line">	foo();</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">// 求等差数列第n项的值</div><div class="line">// 2,4,6,8,10</div><div class="line">// 第一项的值 v</div><div class="line">// 等差：	  d</div><div class="line">// n 等差数列第n项</div><div class="line">// 规律：</div><div class="line">// 第一项值 为 v</div><div class="line">// 第二项值 为 v + d</div><div class="line">// 第三项值 为 第二项值 + d</div><div class="line">// 。。。</div><div class="line">// 第n项值  为 第n-1项值 + d</div><div class="line">function dengCha(v, d, n) &#123;</div><div class="line">	// 过滤n小于1的无效值</div><div class="line">	if (n &lt; 1) &#123;</div><div class="line">		return undefined;</div><div class="line">	&#125;</div><div class="line">	// 如果n为1，就直接返回v。此时不需要递归</div><div class="line">	else if( n === 1)&#123;</div><div class="line">		return v;</div><div class="line">	&#125;</div><div class="line">	// 如果n大于1，此时需要递归</div><div class="line">	else &#123;</div><div class="line">		return dengCha(v, d, n - 1) + d;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(dengCha(2, 2, 6)); // 12</div></pre></td></tr></table></figure>
<p>  等差递归调用分析图:<img src="./images/等差递归调用分析.jpg" alt="递归分析"><br>b: fibonacci数列第n项值</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">      // fib数列：1, 1, 2, 3, 5, 8, 13, 21, 34,....</div><div class="line">// 规律：</div><div class="line">// 1： 1</div><div class="line">// 2： 1</div><div class="line">// 3： v1 + v2</div><div class="line">// 4： v2 + v3</div><div class="line">// ..</div><div class="line">// n:  vn-2 + vn-1</div><div class="line">      var v = (function (n) &#123;</div><div class="line">	if (n &lt; 1) &#123;</div><div class="line">		return undefined;</div><div class="line">	&#125; else if (n === 1 || n === 2) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return arguments.callee(n - 1) + arguments.callee(n - 2);</div><div class="line">	&#125;</div><div class="line">&#125;(8));</div><div class="line">console.log(v);		//21</div></pre></td></tr></table></figure>
<p>   Fiboncci递归分析:<img src="./images/Fiboncci递归分析.jpg" alt="递归分析"></p>
</li>
<li>词法作用域： 规定变量的作用域是由变量声明的位置决定，而不是由使用变量的位置决定。<pre><code>在词法作用域中，只有函数可以分割作用域。在函数内部是一个完整作用域。与外界隔离
也就是，在函数内部可以访问函数外部的数据；但是函数外部无法访问内部的数据。
</code></pre></li>
<li>变量名（函数名）提升<br>在js预解析阶段执行的操作。<br>js本身是边解析边执行的。</li>
<li>在预解析阶段：<br>首先，分析代码语法，如果有语法错误，就直接抛出异常。<br>其次，将变量名以及函数声明提升 到当前作用域最顶端。</li>
<li>in运算符<br>1》 规则：前面的属性名字，要用字符串来表示；如果为变量，那么会将变量的值隐式转换成字符串，然后去判断变量的值是否为指定对象的属性（可以为继承过来的属性）。<br>2》注意： 后面的参数必须为对象；否则报错。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript进阶篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Function/">Function</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arguments/">arguments</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面向对象之二篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/面向对象之二篇/" class="article-date">
      <time datetime="2016-11-07T07:16:48.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/面向对象之二篇/">面向对象之二篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>面向对象的三大特性<br>1》 封装性： 将复杂的实现过程包装、隐藏起来，给用户提供使用接口。<br>a:好处：就是实现代码的复用；私密性：<br>b:实际使用：只要出现重复代码逻辑，那么就要考虑封装，成一个函数；<br>如果该函数和一些变量的关联性比较大，那么就可以将这些遍历和该函数封装成一个对象。<br>c:注意：保持函数或对象功能的单一性。便于日后维护。</p>
<p>2》继承性： 在js中，继承是体现在对象与对象之间的关系，继承就是指一个对象有权去访问别的对象上的成员。<br>实质：构造函数和类 都是 实例化对象的模板。<br>概念：就是指一个对象有权去访问另一个对象的成员。<br>自己没有，别人有，通过某种方式去使用别人的方法（属性）,拿来主义。<br>在js，只要让一个对象去访问另一个对象的成员的话，就必须要建立继承关系。<br>任何对象都继承自它自己的原型对象。</p>
<p>3》多态性： 体现在子对象和父对象之间： 在父对象上的同一个行为，在各个子对象中的具体实现不同。</p>
</li>
<li><p>继承的实现方式：<br>1》 基于原型<br> a: 扩展原型 ： 在原有的原型上进行相应的扩展，实现继承。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   // 1&gt;基于原型</div><div class="line">// a: 基于原型: 扩展原型</div><div class="line">function A() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">var a = new A;</div><div class="line">A.prototype.printA = function() &#123;</div><div class="line">	console.log(&apos;a&apos;);</div><div class="line">&#125;;</div><div class="line">a.printA();// a</div><div class="line">// a -&gt; A.prototype</div></pre></td></tr></table></figure>
<p> b: 置换原型 ： 将要被继承的对象，直接替换掉原有的原型，实现继承.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// b: 基于原型: 置换原型</div><div class="line">function parent() &#123;</div><div class="line">	this.name = &apos;tom&apos;;</div><div class="line">&#125;</div><div class="line">parent.prototype.printC = function() &#123;</div><div class="line">	console.log(&apos;c&apos;);</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">function child() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">child.prototype = new parent;</div><div class="line">var c = new child;</div><div class="line">c.printC(); // c</div><div class="line">// c -&gt; parent实例 -&gt; parent.prototype</div><div class="line">var name = new child;</div><div class="line">var name = [1, 2, 3];</div><div class="line">console.log(typeof name);</div><div class="line">// 全局变量都是window对象的属性</div><div class="line">// window的name属性只能为字符串</div></pre></td></tr></table></figure>
<p>2》 拷贝继承： 将指定对象上的所有成员拷贝一份，并添加到当前对象上。这种继承方式成为拷贝继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">  	// 2&gt; 拷贝继承：将别的对象上的所有成员拷贝一份，添加到当前对象本身。</div><div class="line">var parent = &#123;</div><div class="line">	print: function() &#123;</div><div class="line">		console.log(&apos;i am &apos; + this.name);</div><div class="line">	&#125;,</div><div class="line">	name: &apos;parent&apos;</div><div class="line">&#125;;</div><div class="line">var child = &#123;</div><div class="line">	name: &apos;child&apos;</div><div class="line">&#125;;</div><div class="line">// 1: 遍历parent</div><div class="line">for (var k in parent) &#123;</div><div class="line">	// 2: 将parent对象上的成员添加到child上。</div><div class="line">	child[k] = parent[k];</div><div class="line">&#125;</div><div class="line">child.print();</div><div class="line">var parent1 = &#123;</div><div class="line">	print1: function() &#123;</div><div class="line">		console.log(&apos;print1&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">for (var k in parent1) &#123;</div><div class="line">	// 2: 将parent对象上的成员添加到child上。</div><div class="line">	child[k] = parent1[k];</div><div class="line">&#125;</div><div class="line">// 封装</div><div class="line">// 封装为child对象一个方法extend，谁调用extend方法就是给谁实现继承。</div><div class="line">child.print1();</div></pre></td></tr></table></figure>
<p>3》 对象冒充： 在一个构造函数中，可以动态的添加一个parent方法，指向已有的构造函数，然后调用parent方法去实例化当前对象的一部分成员（或全部成员）。此时这种方式被称为对象冒充。<br>注意：利用完parent属性之后，记得删除该属性。<br>在实际开发中，两种继承方式可以组合起来应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  function parent(name, age, gender) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.gender = gender;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function child(name, age, gender, address) &#123;</div><div class="line">	this.parent = parent;</div><div class="line">	this.parent(name, age, gender);</div><div class="line">	delete this.parent;</div><div class="line">	this.address = address;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var  c = new child(&apos;xiaoming&apos;, 20, &apos;girl&apos;, &apos;china&apos;);</div><div class="line">console.log(c);</div></pre></td></tr></table></figure>
</li>
<li><p>extend方法的实现： 为了方便去实现拷贝继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// 1: 一次只能继承一个对象</div><div class="line">var child = &#123;&#125;;</div><div class="line"></div><div class="line">child.extend = function(parent) &#123;</div><div class="line">	var k;</div><div class="line">	for( k in parent )&#123;</div><div class="line">		this[k] = parent[k];</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">child.extend(&#123;</div><div class="line">	name: &apos;child&apos;,</div><div class="line">	print: function() &#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">child.print();</div><div class="line"></div><div class="line">// 2: 一次实现继承多个对象</div><div class="line">child.extend = function() &#123;</div><div class="line">	var args = arguments,</div><div class="line">		obj;</div><div class="line">	// 遍历arguments上的所有对象，依次将遍历的每个对象的成员添加到child。</div><div class="line">	for( var i = 0, l = args.length;i &lt; l; i++)&#123;</div><div class="line">		obj = args[i];</div><div class="line">		if( typeof obj === &apos;object&apos;)&#123; // 判断传入的是否为对象，不是对象就不执行下面代码</div><div class="line">			for( var k in obj )&#123;</div><div class="line">				this[k] = obj[k];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">child.extend(&#123;</div><div class="line">	name: &apos;child&apos;</div><div class="line">&#125;, &#123;</div><div class="line">	print: function() &#123;</div><div class="line">		console.log(&apos;i am &apos; + this.name);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.print();</div></pre></td></tr></table></figure>
</li>
<li><p>ES5 Object.create :  通过置换原型的方式来实现继承。<br>Object.create（parent）：返回值为一个新的对象，并且该对象继承自parent对象。(有兼容性问题)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var newObject = Object.create（parent）;</div></pre></td></tr></table></figure>
</li>
<li><p>原型链的概念<br>1》 几个默认<br>a: 所有对象都有<strong>proto</strong>属性，这个属性引用它的原型对象。<br>b: 原型对象继承自Object.prototype，具有constructor属性；如果置换了原型，记得要添加constructor属性。<br>c: 只有函数具有prototype属性（除了Function.prototype）。<br>2》概念：从当前对象到Object.prototype之间，存在一条层次分明，逐级递进的体现继承关系的链式结构，这个结构被称为原型链。</p>
</li>
<li><p>属性搜索原型： 当访问对象成员时，<br>1》 首先，在当前对象上查找，如果找到就直接返回（调用），停止查找;<br>2》如果没有找到，就向其原型对象上查找；如果找到就直接返回（调用），停止查找;<br>3》如果没有找到，就继续向原型对象的原型对象上查找，直到Object.prototype；<br>4》如果找到，那么就直接返回（调用），并停止查找；否则返回undefined（报错：xxx is not a function）<br>注意：<br>1》 如果访问对象的某个属性不存在的话，会搜索整个原型链。会导致js性能降低。<br>2》在实际开发中，尽量保持一个适度的原型链长度。<br>3》兼顾js性能以及代码的可读性可扩展性。</p>
</li>
<li><p>Object.prototype介绍<br>1》 hasOwnProperty：判断当前对象的指定属性是否为自身的，而不是继承过来的；如果是本身的返回true；否则返回false。<br>2》isPrototypeOf：判断当前对象是否为指定对象的原型对象。如果是返回true；否则返回false。<br>如果当前对象出现在指定对象的原型链上就返回true；否则返回false。<br>3》propertyIsEnumerable：即判断指定属性是否为自身的，并且该属性也是可枚举的。<br>只有这两个条件都满足才返回true；否则返回false。</p>
</li>
<li><p>构造函数的执行过程<br>1: 创建了一个空对象obj；<br>2：将obj赋值给this（让this指向obj）<br>3：将当前作用域交给this<br>4：执行构造函数内部的代码<br>5：将 this 返回。（return this;）</p>
</li>
<li><p>绘制对象的原型链<br>绘制规则：<br>1： 绘制出简化的原型链<br>2 : 先将上述简化的原型链上的每一个对象绘制在图形上。<br>3：将每一个对象的默认属性添加上。<br>4：给每一个对象的属性添加指向。<br>5：如果每一个对象的属性都有了指向，说明原型链绘制完成。</p>
</li>
<li>Object对象原型链<br><img src="./images/object对象的原型链.jpg" alt="Object对象原型链"></li>
<li>数组对象原型链<br><img src="./images/数组对象的原型链.jpg" alt="数组对象原型链"></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript进阶篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object-create/">Object.create</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/constructor/">constructor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/extend/">extend()</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面向对象之一篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/面向对象之一篇/" class="article-date">
      <time datetime="2016-11-07T07:13:55.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/面向对象之一篇/">面向对象之一篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>表达式的概念<br> 广义的概念：所有有返回的一段代码块，都可以成为表达式。比如： var a = 0;<br> var a， b;<br> a = 0  这个表达式的返回值为0<br> b = a; 赋值表达式的返回值为 = 的右边“表达式的值”</li>
<li><p>面向对象的概念：<br>一种编程思想。核心：在解决任何问题的时候，首先试图去找到一个对象来帮助解决问题。<br>好处：1》身份：调度者； 2》代码的灵活度高； 3》可维护性高； 4》可扩展性高<br>坏处 : 1》可能造成代码的复杂度提高；2》可读性相对不好</p>
<p>面向过程：身份：执行者<br>顺序：一般情况下不能打乱，从上之下一步一步执行。<br>举个栗子：早上吃买早餐<br>a:  起床，梳洗，打扮<br>b: 拿钱，手机<br>c: 下楼<br>d: 走到摊子<br>e: 排队</p>
</li>
<li><p>JavaScript语言的特点：<br> 1》 弱类型<br> 2》多范式<br> 3》基于对象的语言：在js中，一切都是对象。<br> 4》基于原型的</p>
</li>
<li><p>原型的概念：所谓原型就是一个函数的prototype属性所引用的对象。<br> 只要声明一个函数，那么原型就存在。<br> 当通过该函数创建出来的每一个对象，都共享此原型，<br> 也就是说上述创建出来的所有对象可以直接访问到原型上的任何成员（属性和方法）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;&#125;</div><div class="line">   console.log(foo.prototype);</div><div class="line">   foo.prototype.sayHello = function() &#123;</div><div class="line">       console.log(&quot;go,play.&quot;);</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   foo.prototype[&quot;name&quot;] = &apos;jerry&apos;;</div><div class="line"></div><div class="line">   var f = new foo();</div><div class="line"></div><div class="line">   console.log(f);		//Object</div><div class="line">   console.log(f.constructor);		//foo</div><div class="line">   console.log(f.constructor === foo.prototype.constructor);	//true</div><div class="line">   f.sayHello();		//go,play.</div><div class="line">   console.log(f.name);	//jerry</div></pre></td></tr></table></figure>
</li>
<li><p>原型的本质<br>  就是对象。</p>
</li>
<li>原型的好处<br> 实现同类对象的数据共享。</li>
<li><p>获取原型的方式<br> 1》 通过函数：<code>&lt;fnName&gt;.prototype</code>;<br> 2》通过对象：<code>&lt;object&gt;.__proto__</code>;</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125;</div><div class="line">var f = new foo();</div><div class="line">var f1 = new foo();</div><div class="line">console.log(f.__proto__ === foo.prototype);// true</div><div class="line">var arr =  [];</div><div class="line">console.log(arr.__proto__);</div><div class="line">console.log(Math.__proto__ === Object.prototype);</div><div class="line">var o = &#123;&#125;;</div><div class="line">console.log(o.__proto__ === Object.prototype);</div><div class="line">// 万物生于无而归于无 ---  变量的生命周期</div></pre></td></tr></table></figure>
</li>
<li><p>对象的组成部分： 两部分： a: 对象本身；b: 他的原型<br> 每一个对象都有<code>__proto__</code>属性。那么就是说，每一个对象都有原型</p>
</li>
<li>对象的类型<br> 就是它构造函数的名字</li>
<li>原型属性：站在函数的角度，原型可以被称为该函数的原型属性<br>原型对象：站在对象的角度，原型可以被称为该对象的原型对象</li>
<li><p><code>__proto__</code>兼容：非标准属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">   function getPrototype(obj) &#123;</div><div class="line">      // 判断浏览器是否兼容__proto__</div><div class="line">       if (obj.__proto__) &#123; // 支持</div><div class="line">            return obj.__proto__;</div><div class="line">        &#125; else &#123; // 不支持</div><div class="line">            // 获取该对象的构造函数</div><div class="line">            // 在通过此函数的prototype属性获取其原型对象</div><div class="line">            return obj.constructor.prototype;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//可以用三元表达式来简化代码</div><div class="line">    function getPrototype(obj) &#123;</div><div class="line">        return !!obj.__proto__ ? obj.__proto__ : obj.constructor.prototype;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>原型的特性<br>1》动态性：<br>a:  给原型扩展成员会直接反应到已创建的对象身上<br>b:  替换原型对象，不会反映到已创建出来的对象。但是会直接影响之后创建出来的对象。<br> 2》唯一性：   由同一函数创建出来的所有对象，共享同一个原型对象。<br>3》不可变性： 对象是无法改变原型对象上的任何成员<br>4》继承性：    所有对象都继承自它的原型对象</p>
</li>
<li><p>原型理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">function Dog(name, color, gender) &#123;</div><div class="line">           this.name = name;</div><div class="line">           this.color = color;</div><div class="line">           this.gender = gender;</div><div class="line">       &#125;</div><div class="line">       // Dog.prototype.eat = function() &#123;</div><div class="line">       //     console.log(&apos;吃饭饭&apos;);</div><div class="line">       // &#125;;</div><div class="line">       // Dog.prototype.bark = function() &#123;</div><div class="line">       //     console.log(&apos;wangwang. i am &apos; + this.name);</div><div class="line">       // &#125;;</div><div class="line">       // Dog.prototype.makeup = function() &#123;</div><div class="line">       //</div><div class="line">       // &#125;</div><div class="line">       // 替换原型对象：别忘记给新的原型对象添加constructor属性。</div><div class="line">       var jinmao = new Dog(&apos;金毛&apos;, &apos;goldyellow&apos;, &apos;man&apos;);</div><div class="line">       jinmao.eat();</div><div class="line">       jinmao.bark();</div><div class="line">       jinmao.makeup();</div><div class="line"></div><div class="line">       Dog.prototype = &#123;</div><div class="line">           constructor: Dog,</div><div class="line">           eat: function() &#123;</div><div class="line">               console.log(&apos;吃饭饭&apos;);</div><div class="line">           &#125;,</div><div class="line">           bark: function() &#123;</div><div class="line">               console.log(&apos;wangwang. i am &apos; + this.name);</div><div class="line">           &#125;,</div><div class="line">           makeup: function() &#123;</div><div class="line">               console.log(&apos;i am makeuping. saodeng.waiting for me a moment.&apos;);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">       var erha = new Dog(&apos;二哈&apos;, &apos;BlackWhite&apos;, &apos;female&apos;);</div><div class="line">       erha.eat();</div><div class="line">       erha.bark();</div><div class="line">       erha.makeup();</div></pre></td></tr></table></figure>
</li>
<li><p>标准构造函数的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 哪些属性要保留在构造函数内部，哪些属性要提取出来，放到原型上？</div><div class="line">// 1: 和具体某个对象息息相关的属性，那么这些属性都要写在构造函数内部</div><div class="line">// 2：a:而哪些为了共享的属性，就是每一个对象都具有的属性，并且属性值是确定的,不会随对象变化而发生改变。</div><div class="line">//    b:在一般情况，所有的方法都应该放在原型上。</div><div class="line">// 不提倡在js原生对象上进行扩展成员</div><div class="line">// 坏处：会导致原生对象过于庞大、累赘。影响性能。</div><div class="line">function A(name, age, gender)&#123;</div><div class="line">   this.name = name;</div><div class="line">   this.age = age;</div><div class="line">   this.gender = gender;</div><div class="line">&#125;</div><div class="line">A.prototype.location = &quot;earth&quot;;</div><div class="line">A.prototype.sayHello = function () &#123;</div><div class="line">     console.log(&apos;hello&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>函数与原型的关系<br><img src="./images/01--函数与原型的关系.png" alt="函数与原型的关系"></p>
</li>
<li><p>原型的好处分析<br><img src="./images/02--原型的好处分析.png" alt="原型的好处分析"></p>
</li>
<li><p>替换原型分析图<br><img src="./images/03--替换原型分析图.png" alt="替换原型分析图"></p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript进阶篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/proto/">__proto__</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/prototype/">prototype</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-放大镜效果" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/放大镜效果/" class="article-date">
      <time datetime="2016-11-07T04:54:48.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/放大镜效果/">放大镜效果</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>所说的放大镜效果就是指像淘宝详情页中，当鼠标移动到产品图片上时，会同时出现一张大的图片并且显示的位置和小图片对应，接下来上代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//0 获取页面元素</div><div class="line">   var box = document.getElementById(&quot;box&quot;);</div><div class="line">   var small = box.children[0];</div><div class="line">   var mask = small.children[1];</div><div class="line">   var big = box.children[1];</div><div class="line">   var bigImg = big.children[0];</div><div class="line"></div><div class="line">   //1 移入移出，黄盒子和右侧大图区域显示隐藏</div><div class="line">   small.onmouseover = function () &#123;</div><div class="line">       mask.style.display = &quot;block&quot;;</div><div class="line">       big.style.display = &quot;block&quot;;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   small.onmouseout = function () &#123;</div><div class="line">       mask.style.display = &quot;none&quot;;</div><div class="line">       big.style.display = &quot;none&quot;;</div><div class="line">   &#125;;</div><div class="line">   //2 让黄盒子跟随鼠标</div><div class="line">   small.onmousemove = function (e) &#123;</div><div class="line">       var e = e || window.event;</div><div class="line">       var x = getPageX(e);</div><div class="line">       var y = getPageY(e);</div><div class="line">       var finalX = x - box.offsetLeft - mask.offsetWidth / 2;</div><div class="line">       var finalY = y - box.offsetTop - mask.offsetHeight / 2;</div><div class="line">       //finalX和finalY不能无限的小和无限的大，需要规定边界，最小为0 最大small的宽-mask的宽</div><div class="line"></div><div class="line">       //最小值</div><div class="line">       finalX = finalX &lt; 0 ? 0 : finalX;</div><div class="line">       finalY = finalY &lt; 0 ? 0 : finalY;</div><div class="line"></div><div class="line">       finalX = finalX &gt; this.offsetWidth - mask.offsetWidth ? this.offsetWidth - mask.offsetWidth : finalX;</div><div class="line">       finalY = finalY &gt; this.offsetHeight - mask.offsetHeight ? this.offsetHeight - mask.offsetHeight : finalY;</div><div class="line">       //将两个值设置给mask</div><div class="line">       mask.style.left = finalX + &quot;px&quot;;</div><div class="line">       mask.style.top = finalY + &quot;px&quot;;</div><div class="line"></div><div class="line">       //计算大图与小图之间的比例</div><div class="line">       var scale = bigImg.offsetWidth / small.offsetWidth;</div><div class="line">        //3 设置黄盒子运动的边界</div><div class="line">       //4 让右侧图片对应移动</div><div class="line">       bigImg.style.marginLeft = -finalX * scale + &quot;px&quot;;</div><div class="line">       bigImg.style.marginTop = -finalY * scale + &quot;px&quot;;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript基础篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/offsetHeight/">offsetHeight</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/offsetWidt/">offsetWidt</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-事件相关属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/事件相关属性/" class="article-date">
      <time datetime="2016-11-07T04:10:13.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/事件相关属性/">事件相关属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li><p>事件覆盖的问题</p>
<ul>
<li><p>使用事件源.事件类型的添加事件方式会产生覆盖问题。我们通过一个函数去避免这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function addEvent(tag,fn)&#123;</div><div class="line">//判断当前事件源是否已经添加过事件</div><div class="line">	var oldEvent = tag.onclick;</div><div class="line"> if(typeof oldEvent == &apos;function&apos;) &#123;</div><div class="line"> //如果oldEvent中保存的值是函数，说明添加过事件了，我们需要既执行新的fn，也需要执行旧的代码</div><div class="line"> tag.onclick = function()&#123;</div><div class="line">     oldEvent()l;</div><div class="line">     fn();</div><div class="line">     &#125;;</div><div class="line"> &#125;else&#123;</div><div class="line"> 	tag.onclick = fn;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>添加事件</p>
<ul>
<li><p>自带的添加事件新方式：<br>好处，可以避免事件覆盖问题<br>事件源.addEventListener(“click”,function(){});   ie9以上浏览器支持<br>注意：类型名不加 on。</p>
</li>
<li><p>事件源.attachEvent(“onclick”,function(){})  ie低版本支持<br> 注意，类型名加on</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//因为事件源.事件类型的添加事件方式 会产生覆盖所以我们需要一直不覆盖的添加方式</div><div class="line">  //事件源.addEventListener(事件类型名)</div><div class="line">     box.addEventListener(&quot;click&quot;, function () &#123;</div><div class="line">         //事件处理程序</div><div class="line">         console.log(&quot;今天吃什么&quot;);</div><div class="line">     &#125;);</div><div class="line"></div><div class="line">     box.addEventListener(&quot;click&quot;, fun);</div><div class="line">     btn.addEventListener(&quot;click&quot;, function () &#123;</div><div class="line">         box.removeEventListener(&quot;click&quot;,fun)</div><div class="line">     &#125;)</div><div class="line"></div><div class="line">     function fun()&#123;</div><div class="line">         alert(&quot;hello&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">  //ie低版本支持自身的一种添加方式</div><div class="line">  //事件源.attachEvent(&quot;onclick&quot;，function()&#123;&#125;)</div><div class="line">  box.attachEvent(&quot;onclick&quot;, fun);</div><div class="line">  //    //可以取消通过attachEvent添加的事件</div><div class="line">  btn.onclick = function () &#123;</div><div class="line">      box.detachEvent(&quot;onclick&quot;, fun);</div><div class="line">  &#125;;</div><div class="line">  function fun() &#123;</div><div class="line">      console.log(&quot;hello&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  box.onclick = function () &#123;</div><div class="line">  &#125;;</div><div class="line">  //原始添加方式的取消方式 通过 事件 = null</div><div class="line">  box.onclick = null;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>移除事件的方式</p>
<ul>
<li>addEventListener 的添加方式使用removeEventListener进行移除<br>注意第二个参数的写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(&apos;click&apos;,fun);</div><div class="line">box.addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">	box.removeEventListener(&apos;click&apos;,fun)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">function fun()&#123;</div><div class="line">	alert(&apos;hello&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>事件源.detachEvent(“onclick”,fn)用于取消使用attachEvent添加的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">box.attachEvent(&apos;onclick&apos;,fun);</div><div class="line">btn.onclick = function()&#123;</div><div class="line">	box.detachEvent(&apos;onclick&apos;,fun);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function fun()&#123;</div><div class="line">	console.log(&apos;hello&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>事件冒泡和事件捕获</p>
<ul>
<li>事件冒泡是事件传递的一种方式<br>传递方式为：由最特定的元素触发到最不特定的元素,子向父首先触发当前元素的事件，触发完毕向上传播，如果父级也含有这个事件，触发，再向上，如果没有直接继续向上寻找。<br>通过addEventListener添加的事件，第三个参数为false表示事件冒泡。默认为false.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">box1.addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">	alert(&apos;box1&apos;);</div><div class="line">&#125;,false);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>事件捕获是事件传递的一种方式</p>
<ul>
<li>事件捕获的执行方式，是由外向内（跟冒泡相反）。通过addEventListener添加的事件，第三个参数为true表示事件捕获。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">box1.addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">	alert(&apos;box1&apos;);</div><div class="line">&#125;,true);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>事件对象</p>
<ul>
<li><p>获取方式：<br>   1、当事件触发时，我们可以通过在事件处理程序中接收事件对象。这种获取形式在ie低版本不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.onmousemove = function(e)&#123;</div><div class="line">	console.log(e.type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、在ie低版本中使用window.event作为事件对象，作用和e相同;</p>
</li>
</ul>
</li>
<li><p>事件对象的属性</p>
<ul>
<li>事件对象.type 表示事件的类型，注意是不加on的;</li>
<li>事件对象.clientX和事件对象.clientY可以获取事件触发时鼠标针对浏览器可视区域的横坐标和纵坐标。</li>
<li>事件对象.pageX和事件对象.pageY可以获取事件触发时鼠标针对页面左顶点的横坐标和纵坐标。 有兼容性问题，ie低版本不支持，需要封装函数获取。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> //由于前面已经对scroll()进行了封闭，这里直接调用</div><div class="line">function getPageX(e)&#123;</div><div class="line">	var scrl = scroll();</div><div class="line">   return e.clientX + scrl.left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getPageY(e)&#123;</div><div class="line">	var scrl = scroll();</div><div class="line">   return e.clientY + scrl.top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>其他事件<br>  onmousemove 鼠标移动时触发<br> onmousedown 鼠标点下时触发<br> onmouseup    鼠标抬起时触发</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript基础篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/detachEvent/">.detachEvent</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/addEventListener/">addEventListener</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/attachEvent/">attachEvent</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/removeEventListener/">removeEventListener</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-client系列" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/client系列/" class="article-date">
      <time datetime="2016-11-07T03:44:59.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/client系列/">client系列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li><p>client系列</p>
<ul>
<li><p>clientWidth和clientHeight：<br>偏移offsetWidth: width  +  padding  +  border<br>卷曲scrollWidth: width  +  padding  不包含border   内部内容的大小<br>可视clientWidth: width  +  padding  不包含border</p>
</li>
<li><p>clientTop和clientLeft<br>clientTop和clientLeft没用<br>他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！）</p>
</li>
<li><p>网页可视区宽高<br>页面可视区宽高非常常用，但是有很大的兼容性问题，可以合写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var clientWidth = window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth|| 0;</div></pre></td></tr></table></figure>
</li>
<li><p>封装自己的client()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function client() &#123;</div><div class="line">    return &#123;</div><div class="line">        width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,</div><div class="line">        height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>三大系列总结</p>
<ul>
<li>offset系列：offsetWidth、offsetHeight、offsetLeft、offsetTop、offsetParent</li>
<li>scroll系列：scrollWidth、scrollHeight、scrollLeft、scrollTop、scroll()</li>
<li>client系列：clientWidth、clientHeight、clientLeft、clientTop、client()</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript基础篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/client/">client</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-scroll系列" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/scroll系列/" class="article-date">
      <time datetime="2016-11-07T03:44:29.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/scroll系列/">scroll系列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li><p>scrollHeight和scrollWidth</p>
<ul>
<li>标签内部实际内容的高度/宽度,不计算边框，如果内容不超出盒子，值为盒子的宽高（不带边框）,如果内容超出了盒子，就是从顶部或左部边框内侧一直到内容的最外部分</li>
</ul>
</li>
<li><p>scrollTop和scrollLeft</p>
<ul>
<li>被卷起部分的 顶部/左侧 到可视区域 顶部/左侧 的距离</li>
</ul>
</li>
<li><p>页面滚动座标</p>
<ul>
<li>页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>封装自己的scroll()</p>
<ul>
<li>由于非常常用，每次都写上面那一大堆很麻烦。我们可以模仿JQuery封装一个自己的scroll()方法，返回页面滚动座标<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//通过下面这个函数可以得到页面卷曲的高度/宽度</div><div class="line">    function scroll() &#123;</div><div class="line">        return &#123;</div><div class="line">            //内部代码用于兼容各个浏览器</div><div class="line">            scrollTop: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0,</div><div class="line">            scrollLeft: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //window的滚动事件</div><div class="line">    window.onscroll = function () &#123;</div><div class="line">        //这个对象具有两个属性，分别为当前页面的卷曲高度和宽度</div><div class="line">        var scr = scroll();</div><div class="line">        console.log(scr.scrollLeft);</div><div class="line">        console.log(scr.scrollTop);</div><div class="line"></div><div class="line">    &#125;;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript基础篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scroll/">scroll</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-缓动动画" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/07/缓动动画/" class="article-date">
      <time datetime="2016-11-07T03:30:17.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/缓动动画/">缓动动画</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li><p>匀速动画公式<br>step = 10<br>leader = leader + step</p>
</li>
<li><p>缓动动画公式<br>step = ( target - leader ) / 10<br>leader = leader +  step</p>
</li>
<li><p>缓动动画的优势</p>
<ul>
<li>他的移动是有尽头的。不像基础匀速运动那样无限移动。</li>
<li>有非常逼真的缓动效果，实现的动画效果更细腻。</li>
<li>如果不清除定时器，物体永远跟着目标leader在移动。</li>
</ul>
</li>
</ul>
<ul>
<li>缓动函数封装<ul>
<li>动画函数非常繁琐，但是又经常会用到，所以我们应该进行封装</li>
<li>需求：能够让任意对象移动到指定位置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//封装缓动函数 - 更改任意属性</div><div class="line">  function animate(tag, attr, target) &#123;</div><div class="line">      clearInterval(tag.timer);</div><div class="line">      tag.timer = setInterval(function () &#123;</div><div class="line">          //获取某个样式的当前值</div><div class="line">          //通过getStyle获取left的时候，如果没有设置left的初始值，获取不到值</div><div class="line">          var leader = parseInt(getStyle(tag, attr)) || 0;</div><div class="line">          //step = ( target - leader ) / 10</div><div class="line">          var step = (target - leader) / 10;</div><div class="line">          //处理一下step的值，对step进行向上取整</div><div class="line">          step = leader &gt; target ? Math.floor(step) : Math.ceil(step);</div><div class="line">          //leader = leader +  step</div><div class="line">          leader = leader + step;</div><div class="line"></div><div class="line">          //设置给attr值</div><div class="line">          tag.style[attr] = leader + &quot;px&quot;;</div><div class="line">          if (leader == target) &#123;</div><div class="line">              clearInterval(tag.timer);</div><div class="line">          &#125;</div><div class="line">      &#125;, 17);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //兼容IE</div><div class="line">   function getStyle(tag, attr) &#123;</div><div class="line">      return tag.currentStyle ? tag.currentStyle[attr] : getComputedStyle(tag, null)[attr];</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript基础篇</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动画/">动画</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 weihong Liao
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>